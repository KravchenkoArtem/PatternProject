using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class InterfacesOrAbstract : MonoBehaviour { }

//Один из принципов проектирования гласит, что при создании системы 
//классов надо программировать на уровне интерфейсов, а не их конкретных 
//реализаций.Под интерфейсами в данном случае понимаются не только типы C#, 
//определенные с помощью ключевого слова interface, а определение 
//функционала без его конкретной реализации. То есть под данное определение 
//попадают как собственно интерфейсы, так и абстрактные классы, которые могут 
//иметь абстрактные методы без конкретной реализации.

//Когда следует использовать абстрактные классы:

//1) Если надо определить общий функционал для родственных объектов.
//2) Если мы проектируем довольно большую функциональную единицу, 
//которая содержит много базового функционал.
//3) Если нужно, чтобы все производные классы на всех уровнях 
//наследования имели некоторую общую реализацию.При использовании 
//абстрактных классов, если мы захотим изменить базовый функционал во 
//всех наследниках, то достаточно поменять его в абстрактном базовом классе.

//Если же нам вдруг надо будет поменять название или параметры метода 
//интерфейса, то придется вносить изменения и также во всех классы, которые 
//данный интерфейс реализуют.

//Когда следует использовать интерфейсы:

//1) Если нам надо определить функционал для группы разрозненных объектов, 
//которые могут быть никак не связаны между собой.
//2) Если мы проектируем небольшой функциональный тип

//Ключевыми здесь являются первые пункты, которые можно свести к следующему 
//принципу: если классы относятся к единой системе классификации, то выбирается 
//абстрактный класс.Иначе выбирается интерфейс.

// Пример применеия абстрактного класса. Поскольку данные объекты являются родственными, мы можем выделить у них общие признаки, то в данном случае можно использовать абстрактные классы:
namespace someAbs
{
    public abstract class Vehicle
    {
        public abstract void Move();
    }

    public class Car : Vehicle
    {
        public override void Move()
        {
            Debug.Log("Машина едет");
        }
    }

    public class Bus : Vehicle
    {
        public override void Move()
        {
            Debug.Log("Автобус едет");
        }
    }

    public class Tram : Vehicle
    {
        public override void Move()
        {
            Debug.Log("Трамвай едет");
        }
    }
}
//Абстрактный класс Vehicle определяет абстрактный метод перемещения Move(), а классы-наследники его реализуют.
//Возможная реализация интерфейса c разными реализациями и наследовниями могла бы выглядеть следующим образом:
namespace Interf
{
    public interface IMovable
    {
        void Move();
    }
    public abstract class Vehicle { }

    public class Car : Vehicle, IMovable
    {
        public void Move()
        {
            Debug.Log("Машина едет");
        }
    }

    public class Bus : Vehicle, IMovable
    {
        public void Move()
        {
            Debug.Log("Автобус едет");
        }
    }

    public class Hourse : IMovable
    {
        public void Move()
        {
            Console.WriteLine("Лошадь скачет");
        }
    }

    public class Aircraft : IMovable
    {
        public void Move()
        {
            Console.WriteLine("Самолет летит");
        }
    }
}
//Теперь метод Move() определяется в интерфейсе IMovable, а конкретные классы его реализуют.
//Говоря об использовании абстрактных классов и интерфейсов можно привести еще такую аналогию, 
//как состояние и действие.Как правило, абстрактные классы фокусируются на общем состоянии 
//классов-наследников.В то время как интерфейсы строятся вокруг какого-либо общего действия.

//Таким образом, если разноплановые классы обладают каким-то общим действием, то это действие 
//лучше выносить в интерфейс.А для одноплановых классов, которые имеют общее состояние, лучше 
//определять абстрактный класс.