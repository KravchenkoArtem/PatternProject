using UnityEngine;

public class RelationBetweenClassesandObjects : MonoBehaviour {

    private int set { get; set; }
}

//Наследование
//Наследование является базовым принципом ООП и 
//позволяет одному классу(наследнику) унаследовать функционал 
//другого класса(родительского). Нередко отношения наследования еще 
//называют генерализацией или обобщением.
class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Manager : User
{
    public string Company { get; set; }
}

//Реализация
//Реализация предполагает определение интерфейса и его реализация в классах.
public interface IMovable
{
    void Move();
}
public class Car : IMovable
{
    public void Move()
    {
        Debug.Log("Машина чих-пых");
    }
}

//Ассоциация
//Ассоциация - это отношение, при котором объекты одного типа неким образом 
//связаны с объектами другого типа.Например, объект одного типа содержит 
//или использует объект другого типа.

class Team { }

class Player
{
    //Нередко при отношении ассоциации указывается кратность связей.
    //В данном случае единица у Team и звездочка у Player на диаграмме отражает связь 1 ко многим
    public Team Team { get; set; }
}

//Агрегация и композиция являются частными случаями ассоциации.

//Композиция
//Композиция определяет отношение HAS A, то есть отношение "имеет". 
//Например, в класс автомобиля содержит объект класса электрического двигателя:

public class ElectricEngine { }

public class Mercedes
{
    ElectricEngine engine;
    public Mercedes()
    {
        engine = new ElectricEngine();
    }
}
//При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя.
//При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. 
//И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.
//P.S(здесь мы создаем экземпляр класса, который полностью зависит от класса Mercedes).

//Агрегация
//От композиции следует отличать агрегацию.Она также предполагает отношение HAS A, но реализуется она иначе:
public abstract class Engine { }

public class BMW
{
    Engine engine;
    public BMW(Engine eng)
    {
        engine = eng;
    }
}
//При агрегации реализуется слабая связь, то есть в данном случае 
//объекты BMW и Engine будут равноправны.В конструктор BMW передается 
//ссылка на уже имеющийся объект Engine.И, как правило, определяется 
//ссылка не на конкретный класс, а на абстрактный класс или интерфейс, 
//что увеличивает гибкость программы.
// P.S (т.е мы указываем ссылку на обьект, в связи с чем равноправие).


// !!!!Рекомендации к Зависимости!!!! 

//При проектировании отношений между классами надо учитывать некоторые 
//общие рекомендации.В частности, вместо наследования следует предпочитать 
//композицию.При наследовании весь функционал класса-наследника жестко 
//определен на этапе компиляции. И во время выполнения программы мы не можем 
//его динамически переопределить.А класс-наследник не всегда может переопределить код, 
//который определен в родительском классе.Композиция же позволяет динамически определять 
//поведение объекта во время выполнения, и поэтому является более гибкой.

//Вместо композиции следует предпочитать агрегацию, как более гибкий способ 
//связи компонентов. В то же время не всегда агрегация уместна. Например, у нас 
//есть класс человека, который содержит объект нервной системы.Понятно, что 
//в реальности, по крайней мере на текущий момент, невозможно вовне определить 
//нервную систему и внедрить ее в человека. То есть в данном случае человек будет 
//главным компонентом, а нервная система - зависимым, подчиненным, и их создание и 
//жизненный цикл будет происходить совместно, поэтому здесь лучше выбрать композицию.